(*Generated by Sail from simpl.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypes.
Require Import SailStdpp.ConcurrencyInterface.
Require Import SailStdpp.ConcurrencyInterfaceBuiltins.
Require Import simpl_types.
Import Defs.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition b1 := B1.
#[export] Hint Unfold b1 : sail.
Definition b0 := B0.
#[export] Hint Unfold b0 : sail.
Definition eq_unit (_ : unit) (_ : unit) : bool := true.

Definition neq_int (x : Z) (y : Z) : bool := negb (Z.eqb x y).

Definition neq_bool (x : bool) (y : bool) : bool := negb (Bool.eqb x y).



Definition __id (x : Z) : Z := x.

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb len v0 then vector_truncate v len else zero_extend v len.

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb l n then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n (('b"1")  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shl_int m n else shr_int m (Z.opp n).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shr_int m n else shl_int m (Z.opp n).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb (Z.ltb n 0) (Z.gtb m 0) then Z.sub (Z.quot (Z.add n 1) m) 1
   else if andb (Z.gtb n 0) (Z.ltb m 0) then Z.sub (Z.quot (Z.sub n 1) m) 1
   else Z.quot n m.

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub n (Z.mul m (fdiv_int n m)).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z) : string := String.append str (dec_str x).

Definition _R : vec (register_ref regstate register_value (bits 64)) 31 :=
vec_of_list_len [R30_ref;R29_ref;R28_ref;R27_ref;R26_ref;R25_ref;R24_ref;R23_ref;R22_ref;R21_ref;
                 R20_ref;R19_ref;R18_ref;R17_ref;R16_ref;R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;
                 R10_ref;R9_ref;R8_ref;R7_ref;R6_ref;R5_ref;R4_ref;R3_ref;R2_ref;R1_ref;R0_ref].
#[export] Hint Unfold _R : sail.
Definition wX (n : Z) (value : mword 64) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int n 31 return M (unit) then write_reg (vec_access_dec _R n) value  : M (unit)
    else returnM tt)
    : M (unit).

Definition rX (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 64) :=
   (if neq_int n 31 return M (mword 64) then (reg_deref (vec_access_dec _R n))  : M (mword 64)
    else returnM ((Ox"0000000000000000")  : mword 64))
    : M (mword 64).

Definition rPC '(tt : unit) : M (mword 64) := ((read_reg _PC_ref)  : M (mword 64))  : M (mword 64).

Definition wPC (pc : mword 64) : M (unit) := write_reg _PC_ref pc  : M (unit).

Definition wMem (addr : mword 64) (value : mword 64) : M (unit) :=
   let req : Mem_write_request 8 64 (bits 64) unit unit :=
     {| Mem_write_request_access_kind :=
          AK_explicit
            ({| Explicit_access_kind_variety := AV_plain;
                Explicit_access_kind_strength := AS_normal |});
        Mem_write_request_va := Some addr;
        Mem_write_request_pa := addr;
        Mem_write_request_translation := tt;
        Mem_write_request_size := 8;
        Mem_write_request_value := Some value;
        Mem_write_request_tag := None |} in
   (sail_mem_write req) >>= fun (w__0 : result (option bool) unit) =>
   (match w__0 with | Ok _ => returnM tt | Err _ => exit tt  : M (unit) end)
    : M (unit).

Definition sail_address_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition wMem_Addr (addr : mword 64) : unit := sail_address_announce 64 addr.

Definition execute_StoreRegister (t : Z) (n : Z) (m : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX n) >>= fun (base_addr : bits 64) =>
   (rX m) >>= fun (offset : bits 64) =>
   let addr : bits 64 := add_vec base_addr offset in
   let '(_) := (wMem_Addr addr)  : unit in
   (rX t) >>= fun (data : bits 64) => (wMem addr data)  : M (unit).

Definition rMem (addr : mword 64) : M (mword 64) :=
   let req : Mem_read_request 8 64 (bits 64) unit unit :=
     {| Mem_read_request_access_kind :=
          AK_explicit
            ({| Explicit_access_kind_variety := AV_plain;
                Explicit_access_kind_strength := AS_normal |});
        Mem_read_request_va := Some addr;
        Mem_read_request_pa := addr;
        Mem_read_request_translation := tt;
        Mem_read_request_size := 8;
        Mem_read_request_tag := false |} in
   (sail_mem_read req) >>= fun (w__0 : result ((mword (8 * 8) * option bool)) unit) =>
   (match w__0 with | Ok (value, _) => returnM value | Err _ => exit tt  : M (mword 64) end)
    : M (mword 64).

Definition execute_LoadRegister (t : Z) (n : Z) (m : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX n) >>= fun (base_addr : bits 64) =>
   (rX m) >>= fun (offset : bits 64) =>
   let addr : bits 64 := add_vec base_addr offset in
   (rMem addr) >>= fun (data : bits 64) => (wX t data)  : M (unit).

Definition execute_ExclusiveOr (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   (rX n) >>= fun (operand1 : bits 64) =>
   (rX m) >>= fun (operand2 : bits 64) =>
   let result : bits 64 := xor_vec operand1 operand2 in
   (wX d result)
    : M (unit).

Definition dataMemoryBarrier '(tt : unit) : M (unit) := (sail_barrier tt)  : M (unit).

Definition execute_DataMemoryBarrier '(tt : unit) : M (unit) := (dataMemoryBarrier tt)  : M (unit).

Definition execute_CompareAndBranch (t : Z) (offset : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (rX t) >>= fun (operand : bits 64) =>
   (if eq_vec operand ((Ox"0000000000000000")  : mword 64) return M (unit) then
      (rPC tt) >>= fun (base : bits 64) =>
      let addr : bits 64 := add_vec base offset in
      (wPC addr)
       : M (unit)
    else returnM tt)
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   (match merge_var with
    | LoadRegister (t, n, m) => (execute_LoadRegister t n m)  : M (unit)
    | StoreRegister (t, n, m) => (execute_StoreRegister t n m)  : M (unit)
    | ExclusiveOr (d, n, m) => (execute_ExclusiveOr d n m)  : M (unit)
    | DataMemoryBarrier arg0 => (execute_DataMemoryBarrier arg0)  : M (unit)
    | CompareAndBranch (t, offset) => (execute_CompareAndBranch t offset)  : M (unit)
    end)
    : M (unit).

Definition is_ok {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => true | Err _ => false end.

Definition is_err {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => false | Err _ => true end.

Definition ok_option {a : Type} {b : Type} (r : result a b) : option a :=
   match r with | Ok x => Some x | Err _ => None end.

Definition err_option {a : Type} {b : Type} (r : result a b) : option b :=
   match r with | Ok _ => None | Err err => Some err end.

Definition unwrap_or {a : Type} {b : Type} (r : result a b) (y : a) : a :=
   match r with | Ok x => x | Err _ => y end.

Definition sail_instr_announce {n : Z} (_ : mword n) (*n >? 0*) : unit := tt.

Definition sail_branch_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition sail_reset_registers '(tt : unit) : unit := tt.

Definition sail_synchronize_registers '(tt : unit) : unit := tt.

Definition sail_mark_register {a : Type} (_ : register_ref regstate register_value a) (_ : string)
: unit :=
   tt.

Definition sail_mark_register_pair {a : Type} {b : Type}
(_ : register_ref regstate register_value a) (_ : register_ref regstate register_value b)
(_ : string)
: unit :=
   tt.

Definition sail_ignore_write_to {a : Type} (reg : register_ref regstate register_value a) : unit :=
   sail_mark_register reg "ignore_write".

Definition sail_pick_dependency {a : Type} (reg : register_ref regstate register_value a) : unit :=
   sail_mark_register reg "pick".

Definition __monomorphize {n : Z} (bv : mword n) (*n >=? 0*) : mword n := bv.

Definition undefined_Access_variety '(tt : unit) : M (Access_variety) :=
   (internal_pick [AV_plain; AV_exclusive; AV_atomic_rmw])  : M (Access_variety).

Definition undefined_Access_strength '(tt : unit) : M (Access_strength) :=
   (internal_pick [AS_normal; AS_rel_or_acq; AS_acq_rcpc])  : M (Access_strength).

Definition undefined_Explicit_access_kind '(tt : unit) : M (Explicit_access_kind) :=
   (undefined_Access_variety tt) >>= fun (w__0 : Access_variety) =>
   (undefined_Access_strength tt) >>= fun (w__1 : Access_strength) =>
   returnM ({| Explicit_access_kind_variety := w__0;  Explicit_access_kind_strength := w__1 |}).

Definition mem_read_request_is_exclusive {n : Z} {vasize : Z} {pa : Type}
{translation_summary : Type} {arch_ak : Type}
(request : Mem_read_request n vasize pa translation_summary arch_ak) (*(n >? 0) && (vasize >? 0)*)
: bool :=
   match request.(Mem_read_request_access_kind) with
   | AK_explicit eak =>
      match eak.(Explicit_access_kind_variety) with | AV_exclusive => true | _ => false end
   | _ => false
   end.

Definition mem_read_request_is_ifetch {n : Z} {vasize : Z} {pa : Type} {translation_summary : Type}
{arch_ak : Type} (request : Mem_read_request n vasize pa translation_summary arch_ak)
(*(n >? 0) && (vasize >? 0)*)
: bool :=
   match request.(Mem_read_request_access_kind) with | AK_ifetch tt => true | _ => false end.

Definition __monomorphize_reads : bool := false.
#[export] Hint Unfold __monomorphize_reads : sail.
Definition __monomorphize_writes : bool := false.
#[export] Hint Unfold __monomorphize_writes : sail.
Definition mem_write_request_is_exclusive {n : Z} {vasize : Z} {pa : Type}
{translation_summary : Type} {arch_ak : Type}
(request : Mem_write_request n vasize pa translation_summary arch_ak) (*(n >? 0) && (vasize >? 0)*)
: bool :=
   match request.(Mem_write_request_access_kind) with
   | AK_explicit eak =>
      match eak.(Explicit_access_kind_variety) with | AV_exclusive => true | _ => false end
   | _ => false
   end.

Definition pa_bits (pa : mword 64) : mword 64 := pa.

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector 64) >>= fun (w__0 : mword 64) =>
   write_reg _PC_ref w__0 >>
   (undefined_bitvector 64) >>= fun (w__1 : mword 64) =>
   write_reg R30_ref w__1 >>
   (undefined_bitvector 64) >>= fun (w__2 : mword 64) =>
   write_reg R29_ref w__2 >>
   (undefined_bitvector 64) >>= fun (w__3 : mword 64) =>
   write_reg R28_ref w__3 >>
   (undefined_bitvector 64) >>= fun (w__4 : mword 64) =>
   write_reg R27_ref w__4 >>
   (undefined_bitvector 64) >>= fun (w__5 : mword 64) =>
   write_reg R26_ref w__5 >>
   (undefined_bitvector 64) >>= fun (w__6 : mword 64) =>
   write_reg R25_ref w__6 >>
   (undefined_bitvector 64) >>= fun (w__7 : mword 64) =>
   write_reg R24_ref w__7 >>
   (undefined_bitvector 64) >>= fun (w__8 : mword 64) =>
   write_reg R23_ref w__8 >>
   (undefined_bitvector 64) >>= fun (w__9 : mword 64) =>
   write_reg R22_ref w__9 >>
   (undefined_bitvector 64) >>= fun (w__10 : mword 64) =>
   write_reg R21_ref w__10 >>
   (undefined_bitvector 64) >>= fun (w__11 : mword 64) =>
   write_reg R20_ref w__11 >>
   (undefined_bitvector 64) >>= fun (w__12 : mword 64) =>
   write_reg R19_ref w__12 >>
   (undefined_bitvector 64) >>= fun (w__13 : mword 64) =>
   write_reg R18_ref w__13 >>
   (undefined_bitvector 64) >>= fun (w__14 : mword 64) =>
   write_reg R17_ref w__14 >>
   (undefined_bitvector 64) >>= fun (w__15 : mword 64) =>
   write_reg R16_ref w__15 >>
   (undefined_bitvector 64) >>= fun (w__16 : mword 64) =>
   write_reg R15_ref w__16 >>
   (undefined_bitvector 64) >>= fun (w__17 : mword 64) =>
   write_reg R14_ref w__17 >>
   (undefined_bitvector 64) >>= fun (w__18 : mword 64) =>
   write_reg R13_ref w__18 >>
   (undefined_bitvector 64) >>= fun (w__19 : mword 64) =>
   write_reg R12_ref w__19 >>
   (undefined_bitvector 64) >>= fun (w__20 : mword 64) =>
   write_reg R11_ref w__20 >>
   (undefined_bitvector 64) >>= fun (w__21 : mword 64) =>
   write_reg R10_ref w__21 >>
   (undefined_bitvector 64) >>= fun (w__22 : mword 64) =>
   write_reg R9_ref w__22 >>
   (undefined_bitvector 64) >>= fun (w__23 : mword 64) =>
   write_reg R8_ref w__23 >>
   (undefined_bitvector 64) >>= fun (w__24 : mword 64) =>
   write_reg R7_ref w__24 >>
   (undefined_bitvector 64) >>= fun (w__25 : mword 64) =>
   write_reg R6_ref w__25 >>
   (undefined_bitvector 64) >>= fun (w__26 : mword 64) =>
   write_reg R5_ref w__26 >>
   (undefined_bitvector 64) >>= fun (w__27 : mword 64) =>
   write_reg R4_ref w__27 >>
   (undefined_bitvector 64) >>= fun (w__28 : mword 64) =>
   write_reg R3_ref w__28 >>
   (undefined_bitvector 64) >>= fun (w__29 : mword 64) =>
   write_reg R2_ref w__29 >>
   (undefined_bitvector 64) >>= fun (w__30 : mword 64) =>
   write_reg R1_ref w__30 >>
   (undefined_bitvector 64) >>= fun (w__31 : mword 64) => write_reg R0_ref w__31  : M (unit).

Definition initial_Explicit_access_kind : Explicit_access_kind :=
{| Explicit_access_kind_variety := AV_plain;
   Explicit_access_kind_strength := AS_normal |}.
#[export] Hint Unfold initial_Explicit_access_kind : sail.
Definition initial_regstate : regstate :=
{| R0 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R1 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R2 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R3 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R4 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R5 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R6 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R7 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R8 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R9 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R10 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R11 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R12 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R13 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R14 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R15 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R16 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R17 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R18 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R19 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R20 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R21 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R22 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R23 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R24 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R25 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R26 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R27 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R28 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R29 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   R30 := ('b"0000000000000000000000000000000000000000000000000000000000000000");
   _PC := ('b"0000000000000000000000000000000000000000000000000000000000000000") |}.
#[export] Hint Unfold initial_regstate : sail.


